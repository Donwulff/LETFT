!function: 1. bilinear (bilinear interpolation)
!          2. trilinear (Trilinear interpolation)
!subroutine: 1. nb_del
!            2. nb_del3d
!            3. nb_output
!            4. nb_output3d
!            5. bil_gradient (gradient of bilinear interpolation)
!            6. tril_gradient (gradient of Trilinear interpolation)
!            7. baryc (barycentric interpolation in 2D (triangle))
!            8. baryc3d (barycentric inverpolation in 3D (tetrahedron)
!            9. baryc_grad (gradient of barycentric interpolation)
!            10. localcood (locate the center of line segment in
!                       regular grids)
!            11. localcood3d (locate the center of line segment in
!                         3D regular grids)
!            12. baryc_locat (locate the triangle for barycentric
!                         interpolation)
!            13. baryc_locat3d (locate the point (x,y,z) in which 
!                         tetrahedron)
!            14. raypath (find raypath when giving source and receiver)
!            15. raypath3d (find raypath in 3D when giving source and receiver)
!            16. frech_regular (calculate frechet derivative of regular grids)
!            17. frech_regular3d (calculate frechet derivative of 3d regular grids)
!            18. frech_regul3d2 (calculate frechet derivative of non-uniform 
!                                regular grids)
!            19. frech_tri (calculate frechet derivative of Delauney triangle grids)
!            20. frech_teth (calculate frechet derivative of 3D tetrahedro grids)
!            21. teth_vol (calculate volumn of tetrahedro)
!            22. addnodes (add nodes in Delaunay triangles where ray 
!                       weights are high)
!            23. addnodes3d (add nodes in tetrahedros where ray 
!                       weights are high)
!            24. sphdist (calculate distance in spherical coordinate)
!            25. psurf (determine whethter a point is above or under a surface
!                   , +z is above)
!            26. mergefile (merge a list of files into a single file)
!            27. mergebf (merge a list of binary files into a single file)
!            28. directionvector (calculate the direction vector of a line)
!            29. vfrom1d (calculate velocity of a point from 1d velocity model)
!            30. det3 (calculate determinant of a 3x3 matrix, n!=6)
!            31. det4 (calculate determinant of a 4x4 matrix, n!=24)
!            32. dllocat3d (Delaunay search for tetrahran, locate the tetrahedron
!                      of a given point)
!            33. updateheap
!            34. upheap
!            35. downheap
!            36. detlayer (Determine r in which layer)
!            37. locatcood3d2 (Locate p(x,y,z) in the non-uniform cubics)
!--------------------------------------------------------------------------
module strct

    implicit none
! Paramters for 2D.
    integer,parameter :: maxgrid=100000
    integer,parameter :: maxpathnode=10000
    integer,parameter :: maxtri=5000
    integer,parameter :: maxsource=500
    integer,parameter :: maxreceiver=500
    integer,parameter :: maxdata=25000
    integer,parameter :: maxvel=1000
    integer,parameter :: maxnbnode=5000

! Paramters for 3D
    ! Number of nodes in fmm
    integer,parameter :: maxgrid3d=2000000
    ! Number of nodes on one ray path
    integer,parameter :: maxpathnode3d=10000
    ! Number of tetrahedrons from adaptive nodes
    integer,parameter :: maxteth=500000
    ! Number of sources of fmm
    integer,parameter :: maxsource3d=100
    ! Number of travel times
    integer,parameter :: maxdata3d=1200000
    ! Number of velocity parameters
    integer,parameter :: maxvel3d=50000
    ! Number of narrow band nodes in fmm
    integer,parameter :: maxnbnode3d=100000
    ! Number of total events
    integer,parameter :: maxevn3d=100000
    ! Number of nodes in 1 dimension
    integer,parameter :: maxgrd1d=1000
   
! Parameters for mpi
    integer,parameter :: maxproc=128

! Parameters for physicis constants.
! radii=earth radii + elevation of highest point.
    real(kind=8),parameter :: radii=6.375079d3
    real(kind=8),parameter :: pi=3.14159d0

! Source data structure, 2D and 3D
    type srstrct
        real(kind=8) :: x
        real(kind=8) :: y
    end type

    type srstrct3d
        real(kind=8) :: x
        real(kind=8) :: y
        real(kind=8) :: z
    end type

! Nodes structure, 2D and 3D
! stat=1,0,-1 means alive, narrowband, far away.
! stat=2 is temporary, to avoid duplication.
! nbstat=0 mean the nodes are not in narrowband.        |
! nbstat>0 mean the nodes are in narrowband, in this cas|
! nbstat is the index of the narrowband heap
    type tstrct
        real(kind=8) :: x
        real(kind=8) :: y
        real(kind=8) :: t
        real(kind=8) :: dxx
        integer :: num
        integer :: stat
    end type
       
    type tstrct3d
        real(kind=8) :: x
        real(kind=8) :: y
        real(kind=8) :: z
        real(kind=8) :: t
        real(kind=8) :: dxx
        real(kind=8) :: dyy
        integer :: num
        integer :: nbstat
        integer :: stat
    end type
       
    type pstrct
        type(tstrct),pointer :: p
    end type

    type pstrct3d
        type(tstrct3d),pointer :: p
    end type

    type nb_linklist
        type(tstrct),pointer :: p
        type(nb_linklist),pointer :: prev
        type(nb_linklist),pointer :: next
    end type

    type nb_linklist3d
        type(tstrct3d),pointer :: p
        type(nb_linklist3d),pointer :: prev
        type(nb_linklist3d),pointer :: next
    end type

! Velocity structure, 2D and 3D
    type vstrct
        real(kind=8) :: x
        real(kind=8) :: y
        real(kind=8) :: vel
    end type

    type vstrct3d
        real(kind=8) :: x
        real(kind=8) :: y
        real(kind=8) :: z
        real(kind=8) :: vel
    end type

! Receiver structure, 2D and 3D
    type rcstrct
        real(kind=8) :: x
        real(kind=8) :: y
        real(kind=8) :: t
    end type

    type rcstrct3d
        real(kind=8) :: x
        real(kind=8) :: y
        real(kind=8) :: z
        real(kind=8) :: t
    end type

! G 1st norm structure
    type gnstrct
        real(kind=8) :: val
        integer :: num
    end type

    type pgnstrct
        type(gnstrct),pointer :: p
    end type
contains

! Delete element in nb_linklist.
!-------------------------------------------------------------
subroutine nb_del(item)
implicit none
type(nb_linklist),pointer :: item
type(nb_linklist),pointer :: prev,next

prev=>item%prev
next=>item%next
deallocate(item)
if(associated(prev))prev%next=>next
if(associated(next))next%prev=>prev
item=>next

return

end subroutine nb_del
!-------------------------------------------------------------


! Delete element in nb_linklist3d.
!-------------------------------------------------------------
subroutine nb_del3d(item)
implicit none
type(nb_linklist3d),pointer :: item
type(nb_linklist3d),pointer :: prev,next

prev=>item%prev
next=>item%next
deallocate(item)
if(associated(prev))prev%next=>next
if(associated(next))next%prev=>prev
item=>next

return

end subroutine nb_del3d
!-------------------------------------------------------------



! Output nb_linklist.
!--------------------------------------------------------------
subroutine nb_output(list,fname)
implicit none
type(nb_linklist),pointer :: list,p
character(len=70) :: fname

if(associated(list%prev) .eqv. .false.)then
    p=>list%next
else
    p=>list
end if

if(trim(fname) .eq. 'screen')then
    do while(associated(p))
        write(*,*)p%p
        p=>p%next
    end do
else
    open(900,file=fname,status='replace')
    do while(associated(p))
        write(900,*)p%p
        p=>p%next
    end do
end if


return

end subroutine nb_output
!---------------------------------------------------------------




! Output nb_linklist3d.
!--------------------------------------------------------------
subroutine nb_output3d(list,fname)
implicit none
type(nb_linklist3d),pointer :: list,p
character(len=70) :: fname

if(associated(list%prev) .eqv. .false.)then
    p=>list%next
else
    p=>list
end if

if(trim(fname) .eq. 'screen')then
    do while(associated(p))
        write(*,*)p%p
        p=>p%next
    end do
else
    open(900,file=fname,status='replace')
    do while(associated(p))
        write(900,*)p%p
        p=>p%next
    end do
end if


return

end subroutine nb_output3d
!---------------------------------------------------------------



! Bilinear interpolation for f(x,y)
!---------------------------------------------------------------
real(kind=8) function bilinear(f11,f21,f12,f22,x1,y1,x2,y2,x,y)

implicit none
real(kind=8) :: f11,f21,f12,f22
real(kind=8) :: x1,x2,y1,y2
real(kind=8) :: x,y

if( ((x2-x1)*(y2-y1)) .le. 0d0 )then
    write(*,*)"error in function bilinear(strct.f90)"&
            &,((x2-x1)*(y2-y1))
end if

bilinear=(f11*(x2-x)*(y2-y) + f21*(x-x1)*(y2-y)&
   &+f12*(x2-x)*(y-y1) + f22*(x-x1)*(y-y1))&
   &/((x2-x1)*(y2-y1))

return
end function bilinear
!-----------------------------------------------------------------------




! Trilinear interpolation for f(x,y,z)
! crd:
!       Coordinate, 0 for Cartesian, 1 for spherical
!------------------------------------------------------------------------
real(kind=8) function trilinear(f111,f211,f121,f221,f112,f212,f122,f222,&
                            &x1,y1,z1,x2,y2,z2,x,y,z,crd)

implicit none
real(kind=8) :: f111,f211,f121,f221
real(kind=8) :: f112,f212,f122,f222
real(kind=8) :: x1,x2,y1,y2,z1,z2
real(kind=8) :: x,y,z
real(kind=8) :: xp,yp,zp
real(kind=8) :: xn,yn,zn
integer :: crd

if( ((x2-x1)*(y2-y1)*(z2-z1)) .le. 0d0 )then
    write(*,*)"error in function trilinear(strct.f90)",&
            &((x2-x1)*(y2-y1)*(z2-z1)),x1,x2,y1,y2,z1,z2,&
            &x,y,z
    stop
end if

if(crd .eq. 0)then
    xp=x2-x
    yp=y2-y
    zp=z2-z
    xn=x-x1
    yn=y-y1
    zn=z-z1
else if(crd .eq. 1)then
    xp=(x2-x)*cos(y1*pi/1.8d2)*pi*radii/1.8d2
    yp=(y2-y)*pi*radii/1.8d2
    zp=z2-z
    xn=(x-x1)*cos(y1*pi/1.8d2)*pi*radii/1.8d2
    yn=(y-y1)*pi*radii/1.8d2
    zn=z-z1
end if


trilinear=(((f111*xp + f211*xn)*yp&
          &+(f121*xp + f221*xn)*yn)*zp&
         &+((f112*xp + f212*xn)*yp&
          &+(f122*xp + f222*xn)*yn)*zn)&
          &/((xp+xn)*(yp+yn)*(zp+zn))

return
end function trilinear
!-------------------------------------------------------------------


! Gradient of f(x,y) with bilinear interpolation
!-------------------------------------------------------------------
subroutine bil_gradient(gradx,grady,f11,f21,f12,f22,x1,y1,x2,y2,x,y)

implicit none
real(kind=8) :: f11,f21,f12,f22
real(kind=8) :: gradx,grady
real(kind=8) :: x1,x2,y1,y2
real(kind=8) :: x,y

if( ((x2-x1)*(y2-y1)) .le. 0d0 )then
    write(*,*)"error in subroutine bil_gradient(strct.f90)"&
            &,((x2-x1)*(y2-y1))
end if

gradx=((f21-f11)*(y2-y) + (f22-f12)*(y-y1))&
     &/((x2-x1)*(y2-y1))

grady=((f12-f11)*(x2-x) + (f22-f21)*(x-x1))&
     &/((x2-x1)*(y2-y1))

return

end subroutine bil_gradient
!----------------------------------------------------------------



! Gradient of f(x,y,z) with Trilinear interpolation
!-------------------------------------------------------------------
subroutine tril_gradient(gradx,grady,gradz,f111,f211,f121,f221,&
                &f112,f212,f122,f222,x1,y1,z1,x2,y2,z2,x,y,z)

implicit none
real(kind=8) :: f111,f211,f121,f221
real(kind=8) :: f112,f212,f122,f222
real(kind=8) :: x1,x2,y1,y2,z1,z2
real(kind=8) :: x,y,z
real(kind=8) :: xp,yp,zp
real(kind=8) :: xn,yn,zn
real(kind=8) :: prd
real(kind=8) :: gradx,grady,gradz


if( ((x2-x1)*(y2-y1)*(z2-z1)) .le. 0d0 )then
    write(*,*)"error in subroutine tril_gradient(strct.f90)"&
            &,((x2-x1)*(y2-y1)*(z2-z1))
    stop
end if

xp=x2-x
yp=y2-y
zp=z2-z
xn=x-x1
yn=y-y1
zn=z-z1

prd=(x2-x1)*(y2-y1)*(z2-z1)

gradx=(((f211-f111)*yp + (f221-f121)*yn)*zp&
     &+((f212-f112)*yp + (f222-f122)*yn)*zn)&
     &/prd

grady=(((f121-f111)*xp + (f221-f211)*xn)*zp&
     &+((f122-f112)*xp + (f222-f212)*xn)*zn)&
     &/prd

gradz=(((f112-f111)*xp + (f212-f211)*xn)*yp&
     &+((f122-f121)*xp + (f222-f221)*xn)*yn)&
     &/prd


return

end subroutine tril_gradient
!----------------------------------------------------------------



! Barycentric interpolation in 2D (triangle)
!--------------------------------------------------------------------
subroutine baryc(f,f1,f2,f3,x1,y1,x2,y2,x3,y3,x,y)

implicit none
real(kind=8) :: f
real(kind=8) :: x,y
real(kind=8) :: f1,f2,f3
real(kind=8) :: x1,x2,x3
real(kind=8) :: y1,y2,y3
real(kind=8) :: area
real(kind=8) :: area1,area2,area3

area=abs(x1*y2-x2*y1+x2*y3-x3*y2+x3*y1-x1*y3)

if( area .le. 0d0 )then
    write(*,*)"area of triangle is 0! error in subroutine &
            &baryc(strct.f90)",area
end if

area1=abs(x*y2-x2*y+x2*y3-x3*y2+x3*y-x*y3)
area2=abs(x1*y-x*y1+x*y3-x3*y+x3*y1-x1*y3)
area3=area-area1-area2

f=(f1*area1+f2*area2+f3*area3)/area

return

end subroutine baryc
!-------------------------------------------------------------------------



! Barycentric interpolation in 3D (tetrahedron)
!--------------------------------------------------------------------------
subroutine baryc3d(f,f1,f2,f3,f4,x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4,x,y,z)

implicit none
real(kind=8) :: f
real(kind=8) :: x,y,z
real(kind=8) :: f1,f2,f3,f4
real(kind=8) :: x1,x2,x3,x4
real(kind=8) :: y1,y2,y3,y4
real(kind=8) :: z1,z2,z3,z4
real(kind=8) :: vol
real(kind=8) :: vol1,vol2,vol3,vol4

vol=abs((x1-x4)*(y2-y4)*(z3-z4) + (y1-y4)*(z2-z4)*(x3-x4)&
      &+(z1-z4)*(x2-x4)*(y3-y4) - (x3-x4)*(y2-y4)*(z1-z4)&
      &-(y3-y4)*(z2-z4)*(x1-x4) - (z3-z4)*(x2-x4)*(y1-y4))

if( vol .le. 0d0 )then
    write(*,*)"volume of triangle is 0! error in subroutine &
            &baryc3d(strct.f90)",vol
end if

vol1=abs((x-x4)*(y2-y4)*(z3-z4) + (y-y4)*(z2-z4)*(x3-x4)&
       &+(z-z4)*(x2-x4)*(y3-y4) - (x3-x4)*(y2-y4)*(z-z4)&
       &-(y3-y4)*(z2-z4)*(x-x4) - (z3-z4)*(x2-x4)*(y-y4))

vol2=abs((x1-x4)*(y-y4)*(z3-z4) + (y1-y4)*(z-z4)*(x3-x4)&
       &+(z1-z4)*(x-x4)*(y3-y4) - (x3-x4)*(y-y4)*(z1-z4)&
       &-(y3-y4)*(z-z4)*(x1-x4) - (z3-z4)*(x-x4)*(y1-y4))

vol3=abs((x1-x4)*(y2-y4)*(z-z4) + (y1-y4)*(z2-z4)*(x-x4)&
       &+(z1-z4)*(x2-x4)*(y-y4) - (x-x4)*(y2-y4)*(z1-z4)&
       &-(y-y4)*(z2-z4)*(x1-x4) - (z-z4)*(x2-x4)*(y1-y4))

vol4=vol-vol1-vol2-vol3


f=(f1*vol1+f2*vol2+f3*vol3+f4*vol4)/vol

return

end subroutine baryc3d
!---------------------------------------------------------------------


! Gradient of barycentric interpolation in 2D (triangle)
!--------------------------------------------------------------------
subroutine baryc_grad(gradx,grady,f1,f2,f3,x1,y1,x2,y2,x3,y3,x,y)

implicit none
real(kind=8) :: gradx,grady
real(kind=8) :: x,y
real(kind=8) :: f1,f2,f3
real(kind=8) :: x1,x2,x3
real(kind=8) :: y1,y2,y3
real(kind=8) :: area
real(kind=8) :: area1,area2,area3
real(kind=8) :: gx1,gx2,gx3
real(kind=8) :: gy1,gy2,gy3

area=abs(x1*y2-x2*y1+x2*y3-x3*y2+x3*y1-x1*y3)

if( area .le. 0d0 )then
    write(*,*)"area of triangle is 0! error in subroutine &
            &baryc_grad(strct.f90)",area
end if

area1=x*y2-x2*y+x2*y3-x3*y2+x3*y-x*y3
if(area1 .ge. 0d0)then
    gx1=y2-x2*y+x2*y3-x3*y2+x3*y-y3
    gy1=x*y2-x2+x2*y3-x3*y2+x3-x*y3
else
    gx1=-(y2-x2*y+x2*y3-x3*y2+x3*y-y3)
    gy1=-(x*y2-x2+x2*y3-x3*y2+x3-x*y3)
end if

area2=x1*y-x*y1+x*y3-x3*y+x3*y1-x1*y3
if(area2 .ge. 0d0)then
    gx2=x1*y-y1+y3-x3*y+x3*y1-x1*y3
    gy2=x1-x*y1+x*y3-x3+x3*y1-x1*y3
else
    gx2=-(x1*y-y1+y3-x3*y+x3*y1-x1*y3)
    gy2=-(x1-x*y1+x*y3-x3+x3*y1-x1*y3)
end if

area3=x1*y2-x2*y1+x2*y-x*y2+x*y1-x1*y
if(area3 .ge. 0d0)then
    gx3=x1*y2-x2*y1+x2*y-y2+y1-x1*y
    gy3=x1*y2-x2*y1+x2-x*y2+x*y1-x1
else
    gx3=-(x1*y2-x2*y1+x2*y-y2+y1-x1*y)
    gy3=-(x1*y2-x2*y1+x2-x*y2+x*y1-x1)
end if

gradx=(f1*gx1+f2*gx2+f3*gx3)/area
grady=(f1*gy1+f2*gy2+f3*gy3)/area

return

end subroutine baryc_grad
!---------------------------------------------------------------------



! This subroutine determine the local coordinate of point (x,y).
!----------------------------------------------------------------------
subroutine localcood(x,y,travelt,prv,dx,dy,&
            &minx,maxx,miny,maxy,xnum,ynum)

implicit none
type(tstrct), target :: travelt(maxgrid)
type(pstrct), pointer :: prv(:)
real(kind=8) :: x,y
real(kind=8) :: minx,maxx
real(kind=8) :: miny,maxy
real(kind=8) :: dx,dy
integer :: pnum
integer :: xnum,ynum
integer :: tmplnumx,tmplnumy

!write(*,*)"line574"
!write(*,*)size(prv)
!stop
!allocate(prv(1:4))
if(x .le. minx)then
    if(y .le. miny)then
        pnum=1
    else if(y .lt. maxy)then
        tmplnumy=int((y-miny)/dy)
        pnum=tmplnumy*xnum+1
    else
        pnum=(ynum-2)*xnum+1
    end if
else if(x .lt. maxx)then
    if(y .le. miny)then
        tmplnumx=int((x-minx)/dx)
        pnum=tmplnumx+1
    else if(y .lt. maxy)then
        tmplnumx=int((x-minx)/dx)
        tmplnumy=int((y-miny)/dy)
        pnum=tmplnumy*xnum+tmplnumx+1
    else
        tmplnumx=int((x-minx)/dx)
        pnum=(ynum-2)*xnum+tmplnumx+1
    end if
else
    if(y .le. miny)then
        pnum=xnum-1
    else if(y .lt. maxy)then
        tmplnumy=int((y-miny)/dy)
        pnum=tmplnumy*xnum+xnum-1
    else
        pnum=(ynum-2)*xnum+xnum-1
    end if
end if
prv(1)%p=>travelt(pnum)
prv(2)%p=>travelt(pnum+1)
prv(3)%p=>travelt(pnum+xnum)
prv(4)%p=>travelt(pnum+xnum+1)

!deallocate(prv)

return
end subroutine localcood
!----------------------------------------------------------------------



! This subroutine determine the locating grid of point (x,y,z).
!----------------------------------------------------------------------
subroutine localcood3d(x,y,z,travelt,prv,dx,dy,dz,&
            &minx,maxx,miny,maxy,minz,maxz,xnum,ynum,znum)

implicit none
type(tstrct3d), target :: travelt(maxgrid3d)
type(pstrct3d), pointer :: prv(:)
real(kind=8) :: x,y,z
real(kind=8) :: minx,maxx
real(kind=8) :: miny,maxy
real(kind=8) :: minz,maxz
real(kind=8) :: dx,dy,dz
integer :: pnum
integer :: xnum,ynum,znum
integer :: tmplnumx,tmplnumy,tmplnumz

!allocate(prv(1:8))

if(x .le. minx)then
    if(y .le. miny)then
        if(z .le. minz)then
            pnum=1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+1
        else
            pnum=(znum-2)*xnum*ynum+1
        end if
    else if(y .lt. maxy)then
        tmplnumy=int((y-miny)/dy)
        if(z .le. minz)then
            pnum=tmplnumy*xnum+1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+tmplnumy*xnum+1
        else
            pnum=(znum-2)*xnum*ynum+tmplnumy*xnum+1
        end if
    else
        if(z .le. minz)then
            pnum=(ynum-2)*xnum+1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+(ynum-2)*xnum+1
        else
            pnum=(znum-2)*xnum*ynum+(ynum-2)*xnum+1
        end if
    end if
else if(x .lt. maxx)then
    tmplnumx=int((x-minx)/dx)
    if(y .le. miny)then
        if(z .le. minz)then
            pnum=tmplnumx+1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+tmplnumx+1
        else
            pnum=(znum-2)*xnum*ynum+tmplnumx+1
        end if
    else if(y .lt. maxy)then
        tmplnumy=int((y-miny)/dy)
        if(z .le. minz)then
            pnum=tmplnumy*xnum+tmplnumx+1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+tmplnumy*xnum+tmplnumx+1
        else
            pnum=(znum-2)*xnum*ynum+tmplnumy*xnum+tmplnumx+1
        end if
    else
        if(z .le. minz)then
            pnum=(ynum-2)*xnum+tmplnumx+1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+(ynum-2)*xnum+tmplnumx+1
        else
            pnum=(znum-2)*xnum*ynum+(ynum-2)*xnum+tmplnumx+1
        end if
    end if
else
    if(y .le. miny)then
        if(z .le. minz)then
            pnum=xnum-1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+xnum-1
        else
            pnum=(znum-2)*xnum*ynum+xnum-1
        end if
    else if(y .lt. maxy)then
        tmplnumy=int((y-miny)/dy)
        if(z .le. minz)then
            pnum=tmplnumy*xnum+xnum-1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+tmplnumy*xnum+xnum-1
        else
            pnum=(znum-2)*xnum*ynum+tmplnumy*xnum+xnum-1
        end if
    else
        if(z .le. minz)then
            pnum=(ynum-2)*xnum+xnum-1
        else if(z .lt. maxz)then
            tmplnumz=int((z-minz)/dz)
            pnum=tmplnumz*xnum*ynum+(ynum-2)*xnum+xnum-1
        else
            pnum=(znum-2)*xnum*ynum+(ynum-2)*xnum+xnum-1
        end if
    end if
end if
prv(1)%p=>travelt(pnum)
prv(2)%p=>travelt(pnum+1)
prv(3)%p=>travelt(pnum+xnum)
prv(4)%p=>travelt(pnum+xnum+1)
prv(5)%p=>travelt(pnum+xnum*ynum)
prv(6)%p=>travelt(pnum+xnum*ynum+1)
prv(7)%p=>travelt(pnum+xnum*ynum+xnum)
prv(8)%p=>travelt(pnum+xnum*ynum+xnum+1)

!deallocate(prv)

return
end subroutine localcood3d
!----------------------------------------------------------------------



! This subroutine locates the triangle for barycentric interpolation
!----------------------------------------------------------------------
subroutine baryc_locat(x,y,velnode,tri,trinum,ptri)

implicit none
type(tstrct), target :: velnode(maxgrid)
type(pstrct), pointer :: ptri(:)
real(kind=8) :: x,y
real(kind=8) :: xt(3),yt(3)
real(kind=8) :: a,b,c
integer :: tri(maxtri,3)
integer :: trinum
integer :: it,i

!allocate(ptri(1:3))
do i=1,3
    nullify(ptri(i)%p)
end do


do it=1,trinum
    do i=1,3
        xt(i)=velnode(tri(it,i)+1)%x-x
        yt(i)=velnode(tri(it,i)+1)%y-y
    end do
    a=xt(1)*yt(2)-xt(2)*yt(1)
    b=xt(2)*yt(3)-xt(3)*yt(2)
    if( a*b .ge. -1D-10 )then
        c=xt(3)*yt(1)-xt(1)*yt(3)
        if( (b*c .ge. -1D-10) .and. (c*a .ge. -1D-10) )then
            ptri(1)%p=>velnode(tri(it,1)+1)
            ptri(2)%p=>velnode(tri(it,2)+1)
            ptri(3)%p=>velnode(tri(it,3)+1)
            exit
        end if
    end if
end do

if(associated(ptri(1)%p) .eqv. .false.)then
    write(*,*)"point",x,y,"is not in triangles"
    stop
end if

!deallocate(ptri)

return
end subroutine baryc_locat
!----------------------------------------------------------------------




! This subroutine locates the point (x,y,z) in tethahedrons.
!----------------------------------------------------------------------
subroutine baryc_locat3d(x,y,z,velnode,teth,tethnum,pteth,itet)

implicit none
type(tstrct3d), target :: velnode(maxgrid3d)
type(pstrct3d), pointer :: pteth(:)
real(kind=8) :: x,y,z
real(kind=8) :: x1,x2,x3,xp
real(kind=8) :: y1,y2,y3,yp
real(kind=8) :: z1,z2,z3,zp
real(kind=8) :: vol,vol1,vol2,vol3,vol4
integer :: teth(maxteth,4)
integer :: tethnum
integer :: it,i
integer :: itet

allocate(pteth(1:4))
do i=1,4
    nullify(pteth(i)%p)
end do

do it=1,tethnum
    
    x1=(velnode(teth(it,1)+1)%x-velnode(teth(it,4)+1)%x)*1.0d2
    y1=(velnode(teth(it,1)+1)%y-velnode(teth(it,4)+1)%y)*1.1d2
    z1=velnode(teth(it,1)+1)%z-velnode(teth(it,4)+1)%z
    x2=(velnode(teth(it,2)+1)%x-velnode(teth(it,4)+1)%x)*1.0d2
    y2=(velnode(teth(it,2)+1)%y-velnode(teth(it,4)+1)%y)*1.1d2
    z2=velnode(teth(it,2)+1)%z-velnode(teth(it,4)+1)%z
    x3=(velnode(teth(it,3)+1)%x-velnode(teth(it,4)+1)%x)*1.0d2
    y3=(velnode(teth(it,3)+1)%y-velnode(teth(it,4)+1)%y)*1.1d2
    z3=velnode(teth(it,3)+1)%z-velnode(teth(it,4)+1)%z
    
    call det3(vol,x1,y1,z1,x2,y2,z2,x3,y3,z3)
    
    xp=(x-velnode(teth(it,4)+1)%x)*1.0d2
    yp=(y-velnode(teth(it,4)+1)%y)*1.1d2
    zp=z-velnode(teth(it,4)+1)%z

    call det3(vol1,xp,yp,zp,x2,y2,z2,x3,y3,z3)


    if( (vol*vol1 .ge. 0d0) .or. (abs(vol1/vol) .lt. 1d-12) )then

        call det3(vol2,x1,y1,z1,xp,yp,zp,x3,y3,z3)

        if( (vol*vol2 .ge. 0d0) .or. (abs(vol2/vol) .lt. 1d-12) )then

            call det3(vol3,x1,y1,z1,x2,y2,z2,xp,yp,zp)

            if( (vol*vol3 .ge. 0d0) .or. (abs(vol3/vol) .lt. 1d-12) )then

                x1=(velnode(teth(it,1)+1)%x-x)*1.0d2
                y1=(velnode(teth(it,1)+1)%y-y)*1.1d2
                z1=velnode(teth(it,1)+1)%z-z
                x2=(velnode(teth(it,2)+1)%x-x)*1.0d2
                y2=(velnode(teth(it,2)+1)%y-y)*1.1d2
                z2=velnode(teth(it,2)+1)%z-z
                x3=(velnode(teth(it,3)+1)%x-x)*1.0d2
                y3=(velnode(teth(it,3)+1)%y-y)*1.1d2
                z3=velnode(teth(it,3)+1)%z-z
                
                call det3(vol4,x1,y1,z1,x2,y2,z2,x3,y3,z3)

                if( (vol*vol4 .ge. 0d0) .or. (abs(vol4/vol) .lt. 1d-12) )then
                    pteth(1)%p=>velnode(teth(it,1)+1)
                    pteth(2)%p=>velnode(teth(it,2)+1)
                    pteth(3)%p=>velnode(teth(it,3)+1)
                    pteth(4)%p=>velnode(teth(it,4)+1)
                    itet=it
                    exit
                end if
            end if
        end if
    end if
end do


if(associated(pteth(1)%p) .eqv. .false.)then
    write(*,*)"point",x,y,z,"is not in tethahedron"
    stop
end if

!deallocate(pteth)

return
end subroutine baryc_locat3d
!----------------------------------------------------------------------



! This subroutine finds ray path with knowing travel time of each grid.
!-----------------------------------------------------------------------
subroutine raypath(travelt,receiver,source,path,&
           &    ipth,dx,dy,minx,maxx,miny,maxy,xnum,ynum)

implicit none
type(srstrct) :: path(maxpathnode)
type(rcstrct) :: receiver
type(srstrct) :: source
type(tstrct), target :: travelt(maxgrid)
type(pstrct), pointer :: prv(:)
real(kind=8) :: dtx,dty
real(kind=8) :: dx,dy
real(kind=8) :: minx,maxx
real(kind=8) :: miny,maxy
integer :: ipth
integer :: ith
integer :: xnum,ynum

allocate(prv(1:4))
ipth=1
path(ipth)%x=receiver%x
path(ipth)%y=receiver%y

do while((abs(path(ipth)%x-source%x) .gt. dx) .or.&
&       (abs(path(ipth)%y-source%y) .gt. dy))
        
! Find the local rectangle for next ray path point caculation.
!-------------------------------------------------------------------
    call localcood(path(ipth)%x,path(ipth)%y,travelt,prv,dx,dy,&
    &minx,maxx,miny,maxy,xnum,ynum)
!-------------------------------------------------------------------
! Local rectangle finding ends.

! Caculate next point of ray path
!-------------------------------------------------------------------

    call bil_gradient(dtx,dty,prv(1)%p%t,prv(2)%p%t,prv(3)%p%t,&
    &prv(4)%p%t,prv(1)%p%x,prv(1)%p%y,prv(4)%p%x,prv(4)%p%y,&
    &path(ipth)%x,path(ipth)%y)

    path(ipth+1)%x=path(ipth)%x-(((dx+dy)/8.0d0)*dtx/sqrt(dtx**2+dty**2))
    path(ipth+1)%y=path(ipth)%y-(((dx+dy)/8.0d0)*dty/sqrt(dtx**2+dty**2))
    
    ith=0
    if(path(ipth+1)%x .lt. minx)then
        path(ipth+1)%x=minx
        ith=ith+1
    else if(path(ipth+1)%x .gt. maxx)then
        path(ipth+1)%x=maxx
        ith=ith+1
    else if(path(ipth+1)%y .lt. miny)then
        path(ipth+1)%y=miny
        ith=ith+1
    else if(path(ipth+1)%y .gt. maxy)then
        path(ipth+1)%y=maxy
        ith=ith+1
    end if


    ipth=ipth+1
!------------------------------------------------------------------

end do

path(ipth)%x=source%x
path(ipth)%y=source%y
deallocate(prv)

return

end subroutine raypath
!----------------------------------------------------------------------




! This subroutine finds ray path with knowing travel time of each grid
! in 3D.
!-----------------------------------------------------------------------
subroutine raypath3d(travelt,receiver,source,path,ipth,dx,dy,dz,&
                &minx,maxx,miny,maxy,minz,maxz,xnum,ynum,znum)

implicit none
type(srstrct3d) :: path(maxpathnode3d)
type(rcstrct3d) :: receiver
type(srstrct3d) :: source
type(tstrct3d), target :: travelt(maxgrid3d)
type(pstrct3d), pointer :: prv(:)
real(kind=8) :: dtx,dty,dtz
real(kind=8) :: dx,dy,dz
real(kind=8) :: x(2),y(2),z(2)
real(kind=8) :: pthx,pthy,pthz
real(kind=8) :: psegx,psegy,psegz
real(kind=8) :: minx,maxx
real(kind=8) :: miny,maxy
real(kind=8) :: minz,maxz
real(kind=8) :: gsqrt
real(kind=8) :: reflen
integer :: ipth
integer :: ith
integer :: xnum,ynum,znum

allocate(prv(1:8))

ipth=1
path(ipth)%x=receiver%x
path(ipth)%y=receiver%y
path(ipth)%z=receiver%z

do while((abs(path(ipth)%x-source%x) .gt. dx) .or.&
&        (abs(path(ipth)%y-source%y) .gt. dy) .or.&
&        (abs(path(ipth)%z-source%z) .gt. dz))
        
! Find the local rectangle for next ray path point caculation.
!-------------------------------------------------------------------
    call localcood3d(path(ipth)%x,path(ipth)%y,path(ipth)%z,&
        &travelt,prv,dx,dy,dz,minx,maxx,miny,maxy,minz,maxz,&
        &xnum,ynum,znum)
!-------------------------------------------------------------------
! Local rectangle finding ends.

! Caculate next point of ray path
!-------------------------------------------------------------------

    x(1)=cos(prv(1)%p%y*pi/1.8d2)*prv(1)%p%x*pi*radii/1.8d2
    x(2)=cos(prv(1)%p%y*pi/1.8d2)*prv(8)%p%x*pi*radii/1.8d2
    y(1)=prv(1)%p%y*pi*radii/1.8d2
    y(2)=prv(8)%p%y*pi*radii/1.8d2
    z(1)=prv(1)%p%z
    z(2)=prv(8)%p%z
    pthx=cos(prv(1)%p%y*pi/1.8d2)*path(ipth)%x*pi*radii/1.8d2
    pthy=path(ipth)%y*pi*radii/1.8d2
    pthz=path(ipth)%z
    call tril_gradient(dtx,dty,dtz,prv(1)%p%t,prv(2)%p%t,prv(3)%p%t,&
        &prv(4)%p%t,prv(5)%p%t,prv(6)%p%t,prv(7)%p%t,prv(8)%p%t,&
        &x(1),y(1),z(1),x(2),y(2),z(2),&
        &pthx,pthy,pthz)


    gsqrt=sqrt(dtx**2+dty**2+dtz**2)
    reflen=(abs(x(2)-x(1))+abs(y(2)-y(1))+abs(z(2)-z(1)))/8.0d0
    psegx=reflen*dtx*1.8d2/(gsqrt*pi*radii*cos(prv(1)%p%y*pi/1.8d2))
    psegy=reflen*dty*1.8d2/(gsqrt*pi*radii)
    psegz=reflen*dtz/gsqrt
    path(ipth+1)%x=path(ipth)%x-psegx
    path(ipth+1)%y=path(ipth)%y-psegy
    path(ipth+1)%z=path(ipth)%z-psegz

    ith=0
    if(path(ipth+1)%x .lt. minx)then
        path(ipth+1)%x=minx
        ith=ith+1
    else if(path(ipth+1)%x .gt. maxx)then
        path(ipth+1)%x=maxx
        ith=ith+1
    end if
    if(path(ipth+1)%y .lt. miny)then
        path(ipth+1)%y=miny
        ith=ith+1
    else if(path(ipth+1)%y .gt. maxy)then
        path(ipth+1)%y=maxy
        ith=ith+1
    end if
    if(path(ipth+1)%z .lt. minz)then
        path(ipth+1)%z=minz
        ith=ith+1
    else if(path(ipth+1)%z .gt. maxz)then
        path(ipth+1)%z=maxz
        ith=ith+1
    end if


    ipth=ipth+1
!------------------------------------------------------------------

end do

path(ipth)%x=source%x
path(ipth)%y=source%y
path(ipth)%z=source%z
deallocate(prv)

return

end subroutine raypath3d
!----------------------------------------------------------------------



! This subroutine finds Frechet Derivative for inverse with regular 
! velocity grid.
!-----------------------------------------------------------------------
subroutine frech_regular(vel,path,ipath,fd,dx,dy,minx,maxx,miny,maxy,&
            &xnum,ynum)

implicit none
type(srstrct) :: path(maxpathnode)
type(tstrct), target :: vel(maxgrid)
type(pstrct), pointer :: prv(:)
real(kind=8) :: fd(maxvel)
real(kind=8) :: dx,dy
real(kind=8) :: minx,maxx
real(kind=8) :: miny,maxy
real(kind=8) :: x,y
real(kind=8) :: length
real(kind=8) :: a
integer :: ipath
integer :: xnum,ynum
integer :: i

allocate(prv(1:4))

fd=0d0

do i=1,ipath-1
    x=(path(i)%x+path(i+1)%x)/2.0d0
    y=(path(i)%y+path(i+1)%y)/2.0d0
    length=(sqrt((path(i)%x-path(i+1)%x)**2&
          &+(path(i)%y-path(i+1)%y)**2))*radii&
          &*pi/1.8d2

    call localcood(x,y,vel,prv,dx,dy,minx,maxx,miny,maxy,xnum,ynum)

    a=(prv(4)%p%x-prv(1)%p%x)*(prv(4)%p%y-prv(1)%p%y)
    
    fd(prv(1)%p%num)=length*(prv(4)%p%x-x)*(prv(4)%p%y-y)/a&
                    &+fd(prv(1)%p%num)
    fd(prv(2)%p%num)=length*(x-prv(1)%p%x)*(prv(4)%p%y-y)/a&
                    &+fd(prv(2)%p%num)
    fd(prv(3)%p%num)=length*(prv(4)%p%x-x)*(y-prv(1)%p%y)/a&
                    &+fd(prv(3)%p%num)
    fd(prv(4)%p%num)=length*(x-prv(1)%p%x)*(y-prv(1)%p%y)/a&
                    &+fd(prv(4)%p%num)

end do

deallocate(prv)

return
end subroutine frech_regular
!-----------------------------------------------------------------------




! This subroutine finds Frechet Derivative for inverse with 3d regular 
! velocity grid.
!-----------------------------------------------------------------------
subroutine frech_regular3d(vel,path,ipath,fd,dx,dy,dz,minx,maxx,miny,maxy,&
            &minz,maxz,xnum,ynum,znum)

implicit none
type(srstrct3d) :: path(maxpathnode3d)
type(tstrct3d), target :: vel(maxgrid3d)
type(pstrct3d), pointer :: prv(:)
real(kind=8) :: fd(maxvel3d)
real(kind=8) :: dx,dy,dz
real(kind=8) :: minx,maxx
real(kind=8) :: miny,maxy
real(kind=8) :: minz,maxz
real(kind=8) :: x,y,z
real(kind=8) :: length
real(kind=8) :: a
integer :: ipath
integer :: xnum,ynum,znum
integer :: i

allocate(prv(1:8))

fd=0d0

do i=1,ipath-1
    x=(path(i)%x+path(i+1)%x)/2.0d0
    y=(path(i)%y+path(i+1)%y)/2.0d0
    z=(path(i)%z+path(i+1)%z)/2.0d0
    
    call sphdist(path(i)%x,path(i)%y,path(i)%z,&
                &path(i+1)%x,path(i+1)%y,path(i+1)%z,&
                &length)
    !length=sqrt(((path(i)%x-path(i+1)%x)*cos(path(i)%y*pi/1.8d2)*radii*pi/1.8d2)**2&
    !          &+((path(i)%y-path(i+1)%y)*radii*pi/1.8d2)**2&
    !          &+(path(i)%z-path(i+1)%z)**2)

    call localcood3d(x,y,z,vel,prv,dx,dy,dz,minx,maxx,miny,maxy,&
                    &minz,maxz,xnum,ynum,znum)

    a=(prv(8)%p%x-prv(1)%p%x)*(prv(8)%p%y-prv(1)%p%y)*(prv(8)%p%z-prv(1)%p%z)
    
    fd(prv(1)%p%num)=length*(prv(8)%p%x-x)*(prv(8)%p%y-y)*(prv(8)%p%z-z)/a&
                    &+fd(prv(1)%p%num)
    fd(prv(2)%p%num)=length*(x-prv(1)%p%x)*(prv(8)%p%y-y)*(prv(8)%p%z-z)/a&
                    &+fd(prv(2)%p%num)
    fd(prv(3)%p%num)=length*(prv(8)%p%x-x)*(y-prv(1)%p%y)*(prv(8)%p%z-z)/a&
                    &+fd(prv(3)%p%num)
    fd(prv(4)%p%num)=length*(x-prv(1)%p%x)*(y-prv(1)%p%y)*(prv(8)%p%z-z)/a&
                    &+fd(prv(4)%p%num)
    fd(prv(5)%p%num)=length*(prv(8)%p%x-x)*(prv(8)%p%y-y)*(z-prv(1)%p%z)/a&
                    &+fd(prv(5)%p%num)
    fd(prv(6)%p%num)=length*(x-prv(1)%p%x)*(prv(8)%p%y-y)*(z-prv(1)%p%z)/a&
                    &+fd(prv(6)%p%num)
    fd(prv(7)%p%num)=length*(prv(8)%p%x-x)*(y-prv(1)%p%y)*(z-prv(1)%p%z)/a&
                    &+fd(prv(7)%p%num)
    fd(prv(8)%p%num)=length*(x-prv(1)%p%x)*(y-prv(1)%p%y)*(z-prv(1)%p%z)/a&
                    &+fd(prv(8)%p%num)


end do

deallocate(prv)

return
end subroutine frech_regular3d
!-----------------------------------------------------------------------




! This subroutine finds Frechet Derivative for inverse with 3d regular 
! velocity grid.
!-----------------------------------------------------------------------
subroutine frech_regul3d2(vel,path,ipath,fd,layer,nl)

implicit none
type(srstrct3d) :: path(maxpathnode3d)
type(tstrct3d)  :: vel(maxgrid3d)
real(kind=8) :: fd(maxvel3d)
real(kind=8) :: layer(maxgrd1d,3)
real(kind=8) :: x,y,z
real(kind=8) :: length
real(kind=8) :: a
integer :: nl(3)
integer :: n(8)
integer :: ipath
integer :: i


fd=0d0

do i=1,ipath-1
    x=(path(i)%x+path(i+1)%x)/2.0d0
    y=(path(i)%y+path(i+1)%y)/2.0d0
    z=(path(i)%z+path(i+1)%z)/2.0d0
    
    call sphdist(path(i)%x,path(i)%y,path(i)%z,&
                &path(i+1)%x,path(i+1)%y,path(i+1)%z,&
                &length)
    !length=sqrt(((path(i)%x-path(i+1)%x)*cos(path(i)%y*pi/1.8d2)*radii*pi/1.8d2)**2&
    !          &+((path(i)%y-path(i+1)%y)*radii*pi/1.8d2)**2&
    !          &+(path(i)%z-path(i+1)%z)**2)

    !call localcood3d(x,y,z,vel,prv,dx,dy,dz,minx,maxx,miny,maxy,&
    !                &minz,maxz,xnum,ynum,znum)
    call locatcood3d2(n,nl(1),layer(1:maxgrd1d,1),nl(2),layer(1:maxgrd1d,2)&
                    &,nl(3),layer(1:maxgrd1d,3),x,y,z)

    a=(vel(n(8))%x-vel(n(1))%x)*&
     &(vel(n(8))%y-vel(n(1))%y)*&
     &(vel(n(8))%z-vel(n(1))%z)
    
    fd(n(1))=length*(vel(n(8))%x-x)*(vel(n(8))%y-y)*(vel(n(8))%z-z)/a&
            &+fd(n(1))
    fd(n(2))=length*(x-vel(n(1))%x)*(vel(n(8))%y-y)*(vel(n(8))%z-z)/a&
            &+fd(n(2))
    fd(n(3))=length*(vel(n(8))%x-x)*(y-vel(n(1))%y)*(vel(n(8))%z-z)/a&
            &+fd(n(3))
    fd(n(4))=length*(x-vel(n(1))%x)*(y-vel(n(1))%y)*(vel(n(8))%z-z)/a&
            &+fd(n(4))
    fd(n(5))=length*(vel(n(8))%x-x)*(vel(n(8))%y-y)*(z-vel(n(1))%z)/a&
            &+fd(n(5))
    fd(n(6))=length*(x-vel(n(1))%x)*(vel(n(8))%y-y)*(z-vel(n(1))%z)/a&
            &+fd(n(6))
    fd(n(7))=length*(vel(n(8))%x-x)*(y-vel(n(1))%y)*(z-vel(n(1))%z)/a&
            &+fd(n(7))
    fd(n(8))=length*(x-vel(n(1))%x)*(y-vel(n(1))%y)*(z-vel(n(1))%z)/a&
            &+fd(n(8))


end do


return
end subroutine frech_regul3d2
!-----------------------------------------------------------------------



! This subroutine finds Frechet Derivative for inverse with Delaunay
! triangle velocity grid.
!-----------------------------------------------------------------------
subroutine frech_tri(vel,path,ipath,fd,tri,trinum)

implicit none
type(srstrct) :: path(maxpathnode)
type(tstrct), target :: vel(maxgrid)
type(pstrct), pointer :: prv(:)
real(kind=8) :: fd(maxvel)
real(kind=8) :: x,y
real(kind=8) :: length
real(kind=8) :: area
real(kind=8) :: area1,area2,area3
integer :: tri(maxtri,3)
integer :: trinum
integer :: ipath
integer :: i

allocate(prv(1:3))

fd=0d0

do i=1,ipath-1
    x=(path(i)%x+path(i+1)%x)/2.0d0
    y=(path(i)%y+path(i+1)%y)/2.0d0
    length=(sqrt((path(i)%x-path(i+1)%x)**2&
          &+(path(i)%y-path(i+1)%y)**2))*radii&
          &*pi/1.8d2

    call baryc_locat(x,y,vel,tri,trinum,prv)
    area=abs(prv(1)%p%x*prv(2)%p%y - prv(2)%p%x*prv(1)%p%y&
            &+ prv(2)%p%x*prv(3)%p%y - prv(3)%p%x*prv(2)%p%y&
            &+ prv(3)%p%x*prv(1)%p%y - prv(1)%p%x*prv(3)%p%y)
    
    area1=abs(x*prv(2)%p%y - prv(2)%p%x*y&
            &+ prv(2)%p%x*prv(3)%p%y - prv(3)%p%x*prv(2)%p%y&
            &+ prv(3)%p%x*y - x*prv(3)%p%y)

    area2=abs(prv(1)%p%x*y - x*prv(1)%p%y&
            &+ x*prv(3)%p%y - prv(3)%p%x*y&
            &+ prv(3)%p%x*prv(1)%p%y - prv(1)%p%x*prv(3)%p%y)
    
    area3=area-area1-area2
    fd(prv(1)%p%num)=length*area1/area+fd(prv(1)%p%num)
    fd(prv(2)%p%num)=length*area2/area+fd(prv(2)%p%num)
    fd(prv(3)%p%num)=length*area3/area+fd(prv(3)%p%num)

end do

deallocate(prv)

return
end subroutine frech_tri
!-----------------------------------------------------------------




! This subroutine finds Frechet Derivative for inverse with 3D
! tetrahedro velocity grid.
!-----------------------------------------------------------------
subroutine frech_teth(vel,path,ipath,fd,teth,tethnbr,tethnum)

implicit none
type(srstrct3d) :: path(maxpathnode3d)
type(tstrct3d), target :: vel(maxgrid3d)
type(pstrct3d), pointer :: prv(:)
real(kind=8) :: fd(maxvel3d)
real(kind=8) :: x,y,z
real(kind=8) :: x4,y4,z4
real(kind=8) :: x14,y14,z14
real(kind=8) :: x24,y24,z24
real(kind=8) :: x34,y34,z34
real(kind=8) :: length
real(kind=8) :: vol
real(kind=8) :: vol1,vol2,vol3,vol4
integer :: teth(maxteth,4)
integer :: tethnbr(maxteth,4)
integer :: tethnum
integer :: ipath
integer :: i
integer :: itet

allocate(prv(1:4))

fd=0d0

do i=1,ipath-1

    ! Slowness is chosen at the center of path segment.
    x=(path(i)%x+path(i+1)%x)/2.0d0
    y=(path(i)%y+path(i+1)%y)/2.0d0
    z=(path(i)%z+path(i+1)%z)/2.0d0

    call sphdist(path(i)%x,path(i)%y,path(i)%z,&
                &path(i+1)%x,path(i+1)%y,path(i+1)%z,&
                &length)
    !length=sqrt(((path(i)%x-path(i+1)%x)*radii*pi/1.8d2)**2&
    !          &+((path(i)%y-path(i+1)%y)*radii*pi/1.8d2)**2&
    !          &+(path(i)%z-path(i+1)%z)**2)

    !call baryc_locat3d(x,y,z,vel,teth,tethnum,prv,itet)
    call dllocat3d(x,y,z,vel,teth,tethnbr,tethnum,prv,itet)

    x14=prv(1)%p%x-prv(4)%p%x
    x24=prv(2)%p%x-prv(4)%p%x
    x34=prv(3)%p%x-prv(4)%p%x
    y14=prv(1)%p%y-prv(4)%p%y
    y24=prv(2)%p%y-prv(4)%p%y
    y34=prv(3)%p%y-prv(4)%p%y
    z14=prv(1)%p%z-prv(4)%p%z
    z24=prv(2)%p%z-prv(4)%p%z
    z34=prv(3)%p%z-prv(4)%p%z
    x4=x-prv(4)%p%x
    y4=y-prv(4)%p%y
    z4=z-prv(4)%p%z


    vol=abs(x14*y24*z34 + y14*z24*x34&
          &+z14*x24*y34 - x34*y24*z14&
          &-y34*z24*x14 - z34*x24*y14)


    vol1=abs(x4*y24*z34 + y4*z24*x34&
           &+z4*x24*y34 - x34*y24*z4&
           &-y34*z24*x4 - z34*x24*y4)


    vol2=abs(x14*y4*z34 + y14*z4*x34&
           &+z14*x4*y34 - x34*y4*z14&
           &-y34*z4*x14 - z34*x4*y14)


    vol3=abs(x14*y24*z4 + y14*z24*x4&
           &+z14*x24*y4 - x4*y24*z14&
           &-y4*z24*x14 - z4*x24*y14)


    vol4=vol-vol1-vol2-vol3

    
    fd(prv(1)%p%num)=length*vol1/vol+fd(prv(1)%p%num)
    fd(prv(2)%p%num)=length*vol2/vol+fd(prv(2)%p%num)
    fd(prv(3)%p%num)=length*vol3/vol+fd(prv(3)%p%num)
    fd(prv(4)%p%num)=length*vol4/vol+fd(prv(4)%p%num)

end do

deallocate(prv)

return
end subroutine frech_teth
!-----------------------------------------------------------------



! This subroutine determines 4 points in on a plane or on a
! tetrahedro.
!-----------------------------------------------------------------
subroutine teth_vol(vol,x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4)

implicit none
real(kind=8) :: x1,y1,z1
real(kind=8) :: x2,y2,z2
real(kind=8) :: x3,y3,z3
real(kind=8) :: x4,y4,z4
real(kind=8) :: vol

vol=abs((x1-x4)*(y2-y4)*(z3-z4) + (y1-y4)*(z2-z4)*(x3-x4)&
      &+(z1-z4)*(x2-x4)*(y3-y4) - (x3-x4)*(y2-y4)*(z1-z4)&
      &-(y3-y4)*(z2-z4)*(x1-x4) - (z3-z4)*(x2-x4)*(y1-y4))


return
end subroutine teth_vol
!-----------------------------------------------------------------




! This subroutine add nodes in Delaunay triangles with high ray weights.
! (With triangles which have at least two high ray weights vertexes.)
! Input: nodenum (nodes's numbers which ray weights are high)
!        num (the total num of 'nodenum')
!        weight (ray weight of velocity nodes)
!        tri (Delaunay triangles), 
!        trinum (numbers of D tri), 
!        velnode (velocity nodes),
! Output: x (x coordinates of new nodes which will be added)
!         y (y coordinates of new nodes which will be added)
!         i (the total number of new nodes which will be added)
!-----------------------------------------------------------------------
subroutine addnodes(x,y,i,nodenum,num,weight,velnode,tri,trinum)

implicit none
type(tstrct), target :: velnode(maxgrid)
type(gnstrct) :: weight(maxvel)
real(kind=8) :: x(maxtri),y(maxtri)
real(kind=8) :: weightsum
integer :: tri(maxtri,3)
integer :: nodenum(maxvel)
integer :: it(3)
integer :: itri,trinum
integer :: ind,num
integer :: i,j


i=0
do itri=1,trinum
    j=0
    it=0
    do ind=1,num
        if(nodenum(ind) .eq. (tri(itri,1)+1))then
            j=j+1
            it(1)=it(1)+1
            if(it(1) .ge. 2)then
                write(*,*)"Error in addnode, nodes's numbers &
                &of high ray weight have duplicate"
                stop
            end if
            if(j .ge. 2)exit
        else if(nodenum(ind) .eq. (tri(itri,2)+1))then
            j=j+1
            it(2)=it(2)+1
            if(it(2) .ge. 2)then
                write(*,*)"Error in addnode, nodes's numbers &
                &of high ray weight have duplicate"
                stop
            end if
            if(j .ge. 2)exit
        else if(nodenum(ind) .eq. (tri(itri,3)+1))then
            j=j+1
            it(3)=it(3)+1
            if(it(3) .ge. 2)then
                write(*,*)"Error in addnode, nodes's numbers &
                &of high ray weight have duplicate"
                stop
            end if
            if(j .ge. 2)exit
        end if
    end do
    if(j .ge. 2)then
        i=i+1
        weightsum=weight(tri(itri,1)+1)%val+&
                 &weight(tri(itri,2)+1)%val+&
                 &weight(tri(itri,3)+1)%val
        x(i)=(weight(tri(itri,1)+1)%val*velnode(tri(itri,1)+1)%x&
            &+weight(tri(itri,2)+1)%val*velnode(tri(itri,2)+1)%x&
            &+weight(tri(itri,3)+1)%val*velnode(tri(itri,3)+1)%x&
            &)/weightsum
        y(i)=(weight(tri(itri,1)+1)%val*velnode(tri(itri,1)+1)%y&
            &+weight(tri(itri,2)+1)%val*velnode(tri(itri,2)+1)%y&
            &+weight(tri(itri,3)+1)%val*velnode(tri(itri,3)+1)%y&
            &)/weightsum
    end if
end do


return
end subroutine addnodes
!-----------------------------------------------------------------



! This subroutine add nodes in tetrahedros with high ray weights.
! (With tetrahedros which have at least two high ray weights vertexes.)
! Input: nodenum (numbers of nodes which ray weights are high)
!        num (the total num of 'nodenum')
!        weight (ray weight of velocity nodes)
!        teth (Tetrahedro), 
!        trinum (numbers of Teths), 
!        velnode (adaptive velocity nodes),
!        dthrshd (minimum distance between two new nodes)
! Output: x (x coordinates of new nodes which will be added)
!         y (y coordinates of new nodes which will be added)
!         z (z coordinates of new nodes which will be added)
!         i (the total number of new nodes which will be added)
!-----------------------------------------------------------------------
subroutine addnodes3d(x,y,z,i,nodenum,num,weight,velnode,teth,tethnum,&
                     &dthrshd)

implicit none
type(tstrct3d), target :: velnode(maxgrid3d)
type(gnstrct) :: weight(maxvel3d)
real(kind=8) :: x(maxteth),y(maxteth),z(maxteth)
real(kind=8) :: weightsum
real(kind=8) :: dthrshd,dist
real(kind=8) :: xtemp,ytemp,ztemp
integer :: teth(maxteth,4)
integer :: nodenum(maxvel3d)
integer :: it(4)
integer :: iteth,tethnum
integer :: ind,num
integer :: i,j
integer :: status1,idst

i=0
do iteth=1,tethnum
    j=0
    it=0
    do ind=1,num
        if(nodenum(ind) .eq. (teth(iteth,1)+1))then
            j=j+1
            it(1)=it(1)+1
            if(it(1) .ge. 2)then
                write(*,*)"Error in addnode3d, nodes's numbers &
                &of high ray weight have duplicate"
                stop
            end if
            if(j .ge. 2)exit
        else if(nodenum(ind) .eq. (teth(iteth,2)+1))then
            j=j+1
            it(2)=it(2)+1
            if(it(2) .ge. 2)then
                write(*,*)"Error in addnode3d, nodes's numbers &
                &of high ray weight have duplicate"
                stop
            end if
            if(j .ge. 2)exit
        else if(nodenum(ind) .eq. (teth(iteth,3)+1))then
            j=j+1
            it(3)=it(3)+1
            if(it(3) .ge. 2)then
                write(*,*)"Error in addnode3d, nodes's numbers &
                &of high ray weight have duplicate"
                stop
            end if
            if(j .ge. 2)exit
        else if(nodenum(ind) .eq. (teth(iteth,4)+1))then
            j=j+1
            it(4)=it(4)+1
            if(it(4) .ge. 2)then
                write(*,*)"Error in addnode3d, nodes's numbers &
                &of high ray weight have duplicate"
                stop
            end if
            if(j .ge. 2)exit
        end if
    end do
    if(j .ge. 2)then
        weightsum=weight(teth(iteth,1)+1)%val+&
                 &weight(teth(iteth,2)+1)%val+&
                 &weight(teth(iteth,3)+1)%val+&
                 &weight(teth(iteth,4)+1)%val
        xtemp=(weight(teth(iteth,1)+1)%val*velnode(teth(iteth,1)+1)%x&
            &+weight(teth(iteth,2)+1)%val*velnode(teth(iteth,2)+1)%x&
            &+weight(teth(iteth,3)+1)%val*velnode(teth(iteth,3)+1)%x&
            &+weight(teth(iteth,4)+1)%val*velnode(teth(iteth,4)+1)%x&
            &)/weightsum
        ytemp=(weight(teth(iteth,1)+1)%val*velnode(teth(iteth,1)+1)%y&
            &+weight(teth(iteth,2)+1)%val*velnode(teth(iteth,2)+1)%y&
            &+weight(teth(iteth,3)+1)%val*velnode(teth(iteth,3)+1)%y&
            &+weight(teth(iteth,4)+1)%val*velnode(teth(iteth,4)+1)%y&
            &)/weightsum
        ztemp=(weight(teth(iteth,1)+1)%val*velnode(teth(iteth,1)+1)%z&
            &+weight(teth(iteth,2)+1)%val*velnode(teth(iteth,2)+1)%z&
            &+weight(teth(iteth,3)+1)%val*velnode(teth(iteth,3)+1)%z&
            &+weight(teth(iteth,4)+1)%val*velnode(teth(iteth,4)+1)%z&
            &)/weightsum

        ! The new nodes whose distances with previous nodes are greater
        ! than dthrshd will be accepted.
        if(i .ge. 1)then
            status1=1
            do idst=1,i
                call sphdist(xtemp,ytemp,ztemp,x(idst),y(idst),z(idst),dist)
                if(dist .lt. dthrshd)then
                    status1=0
                    exit
                end if
            end do

            if(status1 .eq. 1)then
                i=i+1
                x(i)=xtemp
                y(i)=ytemp
                z(i)=ztemp
            elseif(status1 .eq. 0)then
                write(*,*)"Distance between two node is too small, node1, node2, dist",&
                        &xtemp,ytemp,ztemp,x(idst),y(idst),z(idst),dist
            else
                write(*,*)"Error in subroutine addnodes3 of strct.f90,&
                         &status1=",status1
            end if
        elseif(i .eq. 0)then
            i=i+1
            x(i)=xtemp
            y(i)=ytemp
            z(i)=ztemp
        else
            write(*,*)"Error in subroutine addnodes3 of strct.f90,&
                     &i=",i
        end if
    end if
end do


return
end subroutine addnodes3d
!-----------------------------------------------------------------


! Calculate the distance between two points in spherical coordinates.
!------------------------------------------------------------------
subroutine sphdist(lon1,lan1,z1,lon2,lan2,z2,dist)

implicit none
real(kind=8) :: lan1,lan2
real(kind=8) :: lon1,lon2
real(kind=8) :: z1,z2
real(kind=8) :: tmp1,tmp2
real(kind=8) :: theta
real(kind=8) :: r1,r2
real(kind=8) :: dist


tmp1=(sin((lan1-lan2)*pi/3.6d2))**2
tmp2=((sin((lon1-lon2)*pi/3.6d2))**2)*cos(lan1*pi/1.8d2)*cos(lan2*pi/1.8d2)

theta=2.0d0*asin(sqrt(tmp1+tmp2))
r1=radii-z1
r2=radii-z2

dist=sqrt(r1*r1+r2*r2-2.0d0*r1*r2*cos(theta))

end subroutine sphdist

!-------------------------------------------------------------------------


!Determine whehter a point(x,y,z) is above the surface or not.
!updown=1,up or on surface; -1,down
!--------------------------------------------------------------------------
subroutine psurf(x,y,z,surfxy,surfz,updown,sminx,smaxx,sminy,smaxy,sxnum,synum)


implicit none
type(tstrct), target :: surfxy(maxgrid)
type(pstrct), pointer :: prv(:)
real(kind=8) :: surfz(maxpathnode)
real(kind=8) :: x,y,z
real(kind=8) :: tx(3),ty(3),tz(3)
real(kind=8) :: sminx,smaxx
real(kind=8) :: sminy,smaxy
real(kind=8) :: sdx,sdy
real(kind=8) :: a
real(kind=8) :: normz
real(kind=8) :: cof
real(kind=8) :: fsurf
integer :: sxnum,synum
integer :: updown

allocate(prv(1:4))
sdx=(smaxx-sminx)/dble(sxnum-1)
sdy=(smaxy-sminy)/dble(synum-1)
call localcood(x,y,surfxy,prv,sdx,sdy,sminx,smaxx,sminy,smaxy,sxnum,synum)


a=(prv(4)%p%y-prv(1)%p%y)/(prv(4)%p%x-prv(1)%p%x)

tx(1)=prv(1)%p%x
tx(3)=prv(4)%p%x
ty(1)=prv(1)%p%y
ty(3)=prv(4)%p%y
tz(1)=surfz(prv(1)%p%num)
tz(3)=surfz(prv(4)%p%num)
if( (y-a*x) .ge. 0d0)then
    tx(2)=prv(3)%p%x
    ty(2)=prv(3)%p%y
    tz(2)=surfz(prv(3)%p%num)
else
    tx(2)=prv(2)%p%x
    ty(2)=prv(2)%p%y
    tz(2)=surfz(prv(2)%p%num)
end if


normz=(tx(2)-tx(1))*(ty(3)-ty(1))-(tx(3)-tx(1))*(ty(2)-ty(1))

if(normz .ge. 0d0)then
    cof=1d0
else
    cof=-1d0
end if

fsurf=cof*((x-tx(1))*(ty(2)-ty(1))*(tz(3)-tz(1))&
         &+(y-ty(1))*(tz(2)-tz(1))*(tx(3)-tx(1))&
         &+(z-tz(1))*(tx(2)-tx(1))*(ty(3)-ty(1))&
         &-(x-tx(1))*(ty(3)-ty(1))*(tz(2)-tz(1))&
         &-(y-ty(1))*(tz(3)-tz(1))*(tx(2)-tx(1))&
         &-(z-tz(1))*(tx(3)-tx(1))*(ty(2)-ty(1)))

if(fsurf .ge. 0d0)then
    updown=1
else
    updown=-1
end if

deallocate(prv)

return
end subroutine psurf
!------------------------------------------------------------------------



! Merge a list of files into a single file.
! pfile: input file list; nf: number of input files;
! sfile: output single file
! ds=0: delete original files; ds=1: keep files
!-------------------------------------------------------------------------
subroutine mergefile(pfile,nf,sfile,ds)

implicit none
integer :: i,nf
integer :: ds
integer :: status1
character(len=70) :: pfile(maxsource3d)
character(len=*) :: sfile
character(len=200) :: tmpchar

open(201,file=sfile,status='replace')
do i=1,nf
    open(301,file=trim(pfile(i)),status='old')
    do while(.true.)
        read(301,'(a)',iostat=status1)tmpchar
        if(status1/=0)exit
        write(201,*)trim(tmpchar)
    end do
    if(ds .eq. 0)then
        close(301,status='delete')
    else if(ds .eq. 1)then
        close(301)
    else
        write(*,*)"error in mergefile of strct.f90!"
        write(*,*)"ds = ",ds
        stop
    end if
end do
close(201)

return
end subroutine mergefile
!-------------------------------------------------------------------------



! Merge a list of binary files into a single file.
! pfile: input file list; nf: number of input files;
! sfile: output single file
! ds=0: delete original files; ds=1: keep files
!-------------------------------------------------------------------------
subroutine mergebf(pfile,nf,reclength,sfile,ds)

implicit none
integer :: i,j,k,nf
integer :: ds,reclength
integer :: status1
character(len=70) :: pfile(maxsource3d)
character(len=*) :: sfile
character(len=reclength) :: tmpchar

open(201,file=sfile,status='replace',form='unformatted',&
    &access='direct',recl=reclength)
j=0
do i=1,nf
    open(301,file=trim(pfile(i)),status='old',form='unformatted',&
        &access='direct',recl=reclength)
    k=0
    do while(.true.)
        k=k+1
        read(301,rec=k,iostat=status1)tmpchar
        if(status1/=0)exit
        j=j+1
        write(201,rec=j)tmpchar
    end do
    if(ds .eq. 0)then
        close(301,status='delete')
    else if(ds .eq. 1)then
        close(301)
    else
        write(*,*)"error in mergebf of strct.f90!"
        write(*,*)"ds = ",ds
        stop
    end if
end do
close(201)

return
end subroutine mergebf
!-------------------------------------------------------------------------



! Calculate the direction vector of a line.
! coord=1: Cartesian coordinate; coord=2: spherical coordinate.
! When use spherical coordinate: x is longitude, y is lantitude.
!------------------------------------------------------------------------
subroutine directionvector(x1,y1,z1,x2,y2,z2,xv,yv,zv,coord)

implicit none
real(kind=8) :: x1,y1,z1
real(kind=8) :: x2,y2,z2
real(kind=8) :: xv,yv,zv
real(kind=8) :: ds
integer :: coord

if(coord .eq. 1)then
    ds=sqrt((x2-x1)**2+(y2-y1)**2+(z2-z1)**2)
else if(coord .eq. 2)then
    call sphdist(x1,y1,z1,x2,y2,z2,ds)
else
    write(*,*)"error in directionvector of strct.f90!"
    write(*,*)"coord = ",coord
end if

xv=(x2-x1)/ds
yv=(y2-y1)/ds
zv=(z2-z1)/ds

return
end subroutine directionvector
!------------------------------------------------------------------------


! Calculate velocity of an point from 1D velocity model.
!-------------------------------------------------------------------------
subroutine vfrom1d(v,depth,vinp,vnum)

implicit none
real(kind=8) :: vinp(maxgrd1d,3)
real(kind=8) :: depth
real(kind=8) :: v
integer :: iv,vnum
integer :: status1

status1=0
do iv=1,vnum
    if((depth .ge. vinp(iv,1)) .and. (depth .lt. vinp(iv,2)))then
        v=vinp(iv,3)
        status1=status1+1
        exit
    end if
end do

if(status1/=1)then
    write(*,*)"Error in vfrom1d in strct.f90!"
    write(*,*)"Status1=",status1,"V=",v
    stop
end if


return
end subroutine vfrom1d

!-------------------------------------------------------------------------


! Calculate determinant of 3x3 matrix
!-------------------------------------------------------------------------
subroutine det3(adet,a11,a12,a13,a21,a22,a23,a31,a32,a33)

implicit none
real(kind=8) :: a11,a12,a13,a21,a22,a23,a31,a32,a33
real(kind=8) :: adet

adet=a11*(a22*a33-a23*a32)-a12*(a21*a33-a23*a31)+a13*(a21*a32-a22*a31)

return
end subroutine det3

!-------------------------------------------------------------------------------


! Calculate determinant of 4x4 matrix
!-------------------------------------------------------------------------
subroutine det4(a,adet)

implicit none
real(kind=8) :: a(4,4)
real(kind=8) :: m(4)
real(kind=8) :: adet


call det3(m(1),a(2,2),a(2,3),a(2,4),&
              &a(3,2),a(3,3),a(3,4),&
              &a(4,2),a(4,3),a(4,4))
call det3(m(2),a(1,2),a(1,3),a(1,4),&
              &a(3,2),a(3,3),a(3,4),&
              &a(4,2),a(4,3),a(4,4))
call det3(m(3),a(1,2),a(1,3),a(1,4),&
              &a(2,2),a(2,3),a(2,4),&
              &a(4,2),a(4,3),a(4,4))
call det3(m(4),a(1,2),a(1,3),a(1,4),&
              &a(2,2),a(2,3),a(2,4),&
              &a(3,2),a(3,3),a(3,4))

adet=a(1,1)*m(1)-a(2,1)*m(2)+a(3,1)*m(3)-a(4,1)*m(4)

return
end subroutine det4

!-------------------------------------------------------------------------------

! This subroutine locates the point (x,y,z) in tethahedrons.
!----------------------------------------------------------------------
subroutine dllocat3d(x,y,z,node,teth,tethnbr,tethnum,pteth,itet)

implicit none
type(tstrct3d), target :: node(maxgrid3d)
type(pstrct3d), pointer :: pteth(:)
real(kind=8) :: x,y,z
real(kind=8) :: x1,x2,x3,xp
real(kind=8) :: y1,y2,y3,yp
real(kind=8) :: z1,z2,z3,zp
real(kind=8) :: vol,vol1,vol2,vol3,vol4
integer :: teth(maxteth,4)
integer :: tethnbr(maxteth,4)
integer :: tethnum
integer :: it,i,iloop
integer :: itet
integer :: j

allocate(pteth(1:4))
do i=1,4
    nullify(pteth(i)%p)
end do


j=0
it=1
iloop=0
do while((iloop .eq. 0) .and. (j .le. tethnum))
    j=j+1 
    !write(*,*)"line1956 in strct.f90:", it
    x1=(node(teth(it,1)+1)%x-node(teth(it,4)+1)%x)*1.0d2
    y1=(node(teth(it,1)+1)%y-node(teth(it,4)+1)%y)*1.1d2
    z1=node(teth(it,1)+1)%z-node(teth(it,4)+1)%z
    x2=(node(teth(it,2)+1)%x-node(teth(it,4)+1)%x)*1.0d2
    y2=(node(teth(it,2)+1)%y-node(teth(it,4)+1)%y)*1.1d2
    z2=node(teth(it,2)+1)%z-node(teth(it,4)+1)%z
    x3=(node(teth(it,3)+1)%x-node(teth(it,4)+1)%x)*1.0d2
    y3=(node(teth(it,3)+1)%y-node(teth(it,4)+1)%y)*1.1d2
    z3=node(teth(it,3)+1)%z-node(teth(it,4)+1)%z
    
    call det3(vol,x1,y1,z1,x2,y2,z2,x3,y3,z3)
    
    xp=(x-node(teth(it,4)+1)%x)*1.0d2
    yp=(y-node(teth(it,4)+1)%y)*1.1d2
    zp=z-node(teth(it,4)+1)%z

    call det3(vol1,xp,yp,zp,x2,y2,z2,x3,y3,z3)

    if( (vol*vol1 .ge. 0d0) .or. (abs(vol1/vol) .lt. 1d-12) )then

        call det3(vol2,x1,y1,z1,xp,yp,zp,x3,y3,z3)

        if( (vol*vol2 .ge. 0d0) .or. (abs(vol2/vol) .lt. 1d-12) )then

            call det3(vol3,x1,y1,z1,x2,y2,z2,xp,yp,zp)

            if( (vol*vol3 .ge. 0d0) .or. (abs(vol3/vol) .lt. 1d-12) )then

                x1=(node(teth(it,1)+1)%x-x)*1.0d2
                y1=(node(teth(it,1)+1)%y-y)*1.1d2
                z1=node(teth(it,1)+1)%z-z
                x2=(node(teth(it,2)+1)%x-x)*1.0d2
                y2=(node(teth(it,2)+1)%y-y)*1.1d2
                z2=node(teth(it,2)+1)%z-z
                x3=(node(teth(it,3)+1)%x-x)*1.0d2
                y3=(node(teth(it,3)+1)%y-y)*1.1d2
                z3=node(teth(it,3)+1)%z-z
                
                call det3(vol4,x1,y1,z1,x2,y2,z2,x3,y3,z3)

                if( (vol*vol4 .ge. 0d0) .or. (abs(vol4/vol) .lt. 1d-12) )then
                    pteth(1)%p=>node(teth(it,1)+1)
                    pteth(2)%p=>node(teth(it,2)+1)
                    pteth(3)%p=>node(teth(it,3)+1)
                    pteth(4)%p=>node(teth(it,4)+1)
                    itet=it
                    iloop=1
                    exit
                else
                    it=tethnbr(it,4)
                end if
            else
                it=tethnbr(it,3)
            end if
        else
            it=tethnbr(it,2)
        end if
    else
        it=tethnbr(it,1)
    end if
    
    if(it .eq. -1)then
        write(*,*)"Point is outside the study area! P(x,y,z):",x,y,z
        exit
    end if
end do


if(associated(pteth(1)%p) .eqv. .false.)then
    write(*,*)"point",x,y,z,"is not in tethahedron"
    stop
end if


return
end subroutine dllocat3d
!----------------------------------------------------------------------




!Update heap when the iheap element changes.s.
!-------------------------------------------------------------------------
subroutine updateheap(travelt,heap,iheap,heaptail)

implicit none
type(tstrct3d) :: travelt(maxgrid3d)
integer :: heap(maxnbnode3d)
integer :: iheap,heaptail


! For iheap which dosen't have parent node.
if(iheap/2 .eq. 0)then
    call downheap(travelt,heap,iheap,heaptail)
else if(iheap*2 .gt. heaptail)then
    call upheap(travelt,heap,iheap)
else
    if(travelt(heap(iheap/2))%t .gt. travelt(heap(iheap))%t)then
        call upheap(travelt,heap,iheap)
    else
        call downheap(travelt,heap,iheap,heaptail)
    end if
end if

return
end subroutine updateheap

!-------------------------------------------------------------------------


! Upheap
!--------------------------------------------------------------------------
subroutine upheap(travelt,heap,iheap)

implicit none
type(tstrct3d) :: travelt(maxgrid3d)
integer :: heap(maxnbnode3d)
integer :: temp
integer :: iheap
integer :: parent,child

child=iheap
parent=child/2
do while(parent .gt. 0)
    if(travelt(heap(child))%t .lt. travelt(heap(parent))%t)then
        ! Switch parent and child, include the index in %nbstat
        travelt(heap(child))%nbstat=parent
        travelt(heap(parent))%nbstat=child
        temp=heap(parent)
        heap(parent)=heap(child)
        heap(child)=temp
        child=parent
        parent=child/2
    else
        travelt(heap(child))%nbstat=child
        parent=0
    end if
end do

return
end subroutine upheap

!------------------------------------------------------------------------


! downheap
!--------------------------------------------------------------------------
subroutine downheap(travelt,heap,iheap,heaptail)

implicit none
type(tstrct3d) :: travelt(maxgrid3d)
integer :: heap(maxnbnode3d)
integer :: temp
integer :: iheap,heaptail
integer :: parent,child

parent=iheap
child=parent*2
do while(child .le. heaptail)
    
    if((child + 1) .le. heaptail)then
        if(travelt(heap(child))%t .gt. travelt(heap(child+1))%t)then
            child=child+1
        end if
    end if
    
    if(travelt(heap(parent))%t .gt. travelt(heap(child))%t)then
        ! Switch parent and child, include the index in %nbstat
        travelt(heap(child))%nbstat=parent
        travelt(heap(parent))%nbstat=child
        temp=heap(parent)
        heap(parent)=heap(child)
        heap(child)=temp
        parent=child
        child=parent*2
    else
        travelt(heap(child))%nbstat=child
        child=heaptail+1
    end if
end do

return
end subroutine downheap

!------------------------------------------------------------------------


! Determin r in which layer
!------------------------------------------------------------------------
subroutine detlayer(n,nl,layer,r)

implicit none
real(kind=8) :: layer(maxgrd1d)
real(kind=8) :: r
integer :: n,nl,i

n=0
do i=1,nl-1
    if(r .lt. layer(i))exit
    n=n+1
end do

if(r .gt. layer(nl))then
    n=n+1
end if

if((n .eq. 0) .or. (n .eq. nl))then
    write(*,*)"Error in detlayer, strct.f90!"
    write(*,*)"r is out of the layers!"
    write(*,*)"r,layer(1),layer(n): ",r,layer(1),layer(nl)
    stop
end if

return

end subroutine detlayer
!------------------------------------------------------------------------------------


! Locate p(x,y,z) in the non-uniform cubics.
subroutine locatcood3d2(n,nxl,xlayer,nyl,ylayer,nzl,zlayer,x,y,z)

implicit none
real(kind=8) :: xlayer(maxgrd1d),ylayer(maxgrd1d),zlayer(maxgrd1d)
real(kind=8) :: x,y,z
integer :: nx,ny,nz
integer :: n(8)
integer :: nxl,nyl,nzl


call detlayer(nx,nxl,xlayer,x)
call detlayer(ny,nyl,ylayer,y)
call detlayer(nz,nzl,zlayer,z)

n(1)=nxl*nyl*(nz-1)+nxl*(ny-1)+nx
n(2)=nxl*nyl*(nz-1)+nxl*(ny-1)+nx+1
n(3)=nxl*nyl*(nz-1)+nxl*ny+nx
n(4)=nxl*nyl*(nz-1)+nxl*ny+nx+1
n(5)=nxl*nyl*nz+nxl*(ny-1)+nx
n(6)=nxl*nyl*nz+nxl*(ny-1)+nx+1
n(7)=nxl*nyl*nz+nxl*ny+nx
n(8)=nxl*nyl*nz+nxl*ny+nx+1


return
end subroutine locatcood3d2
!-------------------------------------------------------------------------------


end module strct

!-------------------------------------------------------------------------

